+++++++++++++++++++++++++++++++++++++ 
2023-05-13 23:50:32.560981
 
+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (vertices)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 


+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (colours)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 


+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
  ,
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
  ,
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d


+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d


+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
find C : map
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d


+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d
such that 
  t in C
such that 
  t[1]  = t[2] 


+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R


+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find S : Rtype
such that 
  forAll (x,y) in S . 
  (y,x) in R
  ,
  forAll (x,y) in R . 
  (y,x) in S


+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that 
  exists j : D . 
  (i,j) in R


etest4.essence
Expected "that" but got: thatÂ .Token Num: 43
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation((1,2)(1,3))
find u : T
such that 
  exists t in R . 
  t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 


+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R


graph-shortcheaptour-2017070301.essence
Invalid statement:language Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  true


+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  c = 0 + 1


r-sum-2.essence
Invalid statement:given Token Num: 0
----------------------------- 
r-sum.essence
Invalid statement:given Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
2023-05-14 01:56:06.617183
 
+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (vertices)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (colours)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
  ,
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
  ,
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
find C : map
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d
such that 
  t in C
such that 
  t[1]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find S : Rtype
such that 
  forAll (x,y) in S . 
  (y,x) in R
  ,
  forAll (x,y) in R . 
  (y,x) in S

+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that 
  exists j : D . 
  (i,j) in R

etest4.essence
Expected "that" but got: thatÂ .Token Num: 43
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation((1,2)(1,3))
find u : T
such that 
  exists t in R . 
  t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

graph-shortcheaptour-2017070301.essence
Invalid statement:language Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  true

+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  c = 0 + 1

r-sum-2.essence
Invalid statement:given Token Num: 0
----------------------------- 
r-sum.essence
Invalid statement:given Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
2023-05-14 01:56:50.427447
 
+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (vertices)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (colours)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
  ,
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
  ,
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
find C : map
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d
such that 
  t in C
such that 
  t[1]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find S : Rtype
such that 
  forAll (x,y) in S . 
  (y,x) in R
  ,
  forAll (x,y) in R . 
  (y,x) in S

+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that 
  exists j : D . 
  (i,j) in R

etest4.essence
Expected "that" but got: thatÂ .Token Num: 43
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation((1,2)(1,3))
find u : T
such that 
  exists t in R . 
  t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

graph-shortcheaptour-2017070301.essence
Invalid statement:language Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  true

+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  c = 0 + 1

r-sum-2.essence
Invalid statement:given Token Num: 0
----------------------------- 
r-sum.essence
Invalid statement:given Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
2023-05-15 20:53:05.283805
 
+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (vertices)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (colours)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
  ,
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
  ,
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
find C : map
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d
such that 
  t in C
such that 
  t[1]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find S : Rtype
such that 
  forAll (x,y) in S . 
  (y,x) in R
  ,
  forAll (x,y) in R . 
  (y,x) in S

+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that 
  exists j : D . 
  (i,j) in R

etest4.essence
Expected "that" but got: thatÂ .Token Num: 43
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation((1,2)(1,3))
find u : T
such that 
  exists t in R . 
  t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

graph-shortcheaptour-2017070301.essence
Invalid statement:language Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  true

+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  c = 0 + 1

r-sum-2.essence
Invalid statement:given Token Num: 0
----------------------------- 
r-sum.essence
Invalid statement:given Token Num: 0
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
2023-08-09 19:01:57.791757
 
+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
find C : map
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that 
  exists j : D . 
  (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
etest4.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such thatÂ Â exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  c = 0 + 1

+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (colours)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
treeGen.essence
+++++++++++++ Original ++++++++++++++++ 
letting n be 12
letting vertices be domain int(0..n)
find edges : relation (size n) of (vertices * vertices)
such that
    forAll edge,edge2 in edges .
        edge[2] > edge[1] /\
        ((edge != edge2) -> (edge[2] != edge2[2]))
* * * * * * Post Icing * * * * * * * 
letting n be 12
letting vertices be domain int(0..n)
find edges : relation (size n)  of (vertices*vertices)
such that 
  forAll edge,edge2 in edges . 
  edge[2]  > edge[1]  /\ ( edge != edge2 -> edge[2]  != edge2[2]  )

+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

r-sum.essence
can only concatenate str (not "NoneType") to str
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d
such that 
  t in C
such that 
  t[1]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find S : Rtype
such that 
  forAll (x,y) in S . 
  (y,x) in R
  ,
  forAll (x,y) in R . 
  (y,x) in S

graph-shortcheaptour-2017070301.essence
Invalid statement:language Token Num: 0
----------------------------- 
gc-simple.essence
Invalid statement:of Token Num: 18
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
  ,
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
  ,
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
testExpression.essence
+++++++++++++ Original ++++++++++++++++ 
letting a be 1
letting b be 9
letting c be 11
letting d be 100
find Y : int(0..100)
such that 
  Y < c /\ Y < d /\ a < Y /\ b < Y

* * * * * * Post Icing * * * * * * * 
letting a be 1
letting b be 9
letting c be 11
letting d be 100
find Y : int(0..100)
such that 
  Y < c /\ Y < d /\ a < Y /\ b < Y

r-sum-2.essence
can only concatenate str (not "NoneType") to str
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (vertices)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
testExpression2.essence
+++++++++++++ Original ++++++++++++++++ 
find i : int(0..100)
such that 
  i = 2 * 1 + 3 * 4

* * * * * * Post Icing * * * * * * * 
find i : int(0..100)
such that 
  i = 2 * 1 + 3 * 4

+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation((1,2)(1,3))
find u : T
such that 
  exists t in R . 
  t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  true

+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
2023-10-10 18:26:10.825185
 
+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
find C : map
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that 
  exists j : D . 
  (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
etest4.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such thatÂ Â exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
deMorgTestOutput.essence
+++++++++++++ Original ++++++++++++++++ 
find a : bool
find b : bool
find c : bool
such that 
  a = ! ( b \/ c )

* * * * * * Post Icing * * * * * * * 
find a : bool
find b : bool
find c : bool
such that 
  a = ! ( b \/ c )

+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  c = 0 + 1

+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (colours)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
treeGen.essence
+++++++++++++ Original ++++++++++++++++ 
letting n be 12
letting vertices be domain int(0..n)
find edges : relation (size n) of (vertices * vertices)
such that
    forAll edge,edge2 in edges .
        edge[2] > edge[1] /\
        ((edge != edge2) -> (edge[2] != edge2[2]))
* * * * * * Post Icing * * * * * * * 
letting n be 12
letting vertices be domain int(0..n)
find edges : relation (size n)  of (vertices*vertices)
such that 
  forAll edge,edge2 in edges . 
  edge[2]  > edge[1]  /\ ( edge != edge2 -> edge[2]  != edge2[2]  )

+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
r-sum.essence
+++++++++++++ Original ++++++++++++++++ 
given a : int
find c : int(a..a+1)
such that
  c = 1 + a

* * * * * * Post Icing * * * * * * * 
given a : int(c..a + 1)
such that 
  c = 1 + a

+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
such that 
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
such that 
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d
such that 
  t in C
such that 
  t[1]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find S : Rtype
such that 
  forAll (x,y) in S . 
  (y,x) in R
  ,
  forAll (x,y) in R . 
  (y,x) in S

graph-shortcheaptour-2017070301.essence
Invalid statement:language Token Num: 0
----------------------------- 
gc-simple.essence
Invalid statement:of Token Num: 18
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2)(1,3)(2,3))
find C : relation of (vertices*colours)
such that 
  forAll (u,c) in C . 
  forAll (v,d) in C . 
  u = v -> c = d
  ,
  forAll u : vertices . 
  exists c : colours . 
  C(u,c)
  ,
  forAll (u,v) in G . 
  forAll c,d : colours . 
  C(u,c) /\ C(v,d) -> c != d

+++++++++++++++++++++++++++++++++++++ 
testExpression.essence
+++++++++++++ Original ++++++++++++++++ 
letting a be 1
letting b be 9
letting c be 11
letting d be 100
find Y : int(0..100)
such that 
  Y < c /\ Y < d /\ Y > a /\ b < Y

* * * * * * Post Icing * * * * * * * 
letting a be 1
letting b be 9
letting c be 11
letting d be 100
find Y : int(0..100)
such that 
  Y < c /\ Y < d /\ Y > a /\ b < Y

+++++++++++++++++++++++++++++++++++++ 
r-sum-2.essence
+++++++++++++ Original ++++++++++++++++ 
given a : int
find c : int(a..a+2)
such that
  c = 2 + a

* * * * * * Post Icing * * * * * * * 
given a : int(c..a + 2)
such that 
  c = 2 + a

+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation((1,2)(1,3)(2,3)(4,5)(5,6)(6,7)(7,8)(7,9)(8,9)(9,10)(3,4)(6,1)(2,6)(6,3)(10,8)(1,8))
find C : relation of (vertices)
such that 
  forAll (u,v) in G . 
  C[u]  != C[v] 

+++++++++++++++++++++++++++++++++++++ 
testExpression2.essence
+++++++++++++ Original ++++++++++++++++ 
find i : int(0..100)
such that 
  i = 2 * 1 + 3 * 4

* * * * * * Post Icing * * * * * * * 
find i : int(0..100)
such that 
  i = 2 * 1 + 3 * 4

+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation((1,2)(1,3))
find u : T
such that 
  exists t in R . 
  t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
deMorgTest.essence
+++++++++++++ Original ++++++++++++++++ 

find a : bool
find b : bool
find c : bool
such that
    a = !(b /\ c)
* * * * * * Post Icing * * * * * * * 
find a : bool
find b : bool
find c : bool
such that 
  a = ! ( b /\ c )

+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that 
  true

+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation((1,2)(1,3))
find i : D
such that 
  exists j : D . 
  (i,j) in R
  ,
  forAll k : D . 
  forAll j : D . 
  (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
2024-10-03 15:40:52.709274
 
r-sum.essence
'int' object has no attribute 'children'
----------------------------- 
subsetdiff3.essence
Missing Expression at: 7
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
r-sum-0.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 true

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that
 true

+++++++++++++++++++++++++++++++++++++ 
egraph3col3.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours) $ a function, really
such that
  $ function
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
  $ total
, forAll u : vertices .
     exists c : colours . C(u,c)
  $ proper colouring
, forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation(((1,2),(1,3),(2,3))((1,2),(1,3),(2,3))((1,2),(1,3),(2,3)))
find C : relation of (vertices*colours)
such that
   forAll (u,c) in C .
   forAll (v,d) in C .
     u = v -> c = d
   ,
   forAll u : vertices .
   exists c : colours .
     C(u,c)
   ,
   forAll (u,v) in G .
   forAll c,d : colours .
     C(u,c) /\ C(v,d) -> c != d

nestedfunctionpartialmatrix.essence
Domain Parsing Error. Token: matrix. Token Num: 24
----------------------------- 
gcrel.essence
Missing Expression at: 34
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
stalltest2.essence
+++++++++++++ Original ++++++++++++++++ 
$$$ search for the shortest stall $$$
$find VAR_0 : function function int(0..3) --> int(0..3) --> int(0..2)

$letting AUX_0 be domain set (maxSize 4) of tuple(int(0..3),int(0..3))
$find VAR_0 : set of tuple(AUX_0, int(0..2))
$
$find VAR_0 : function (total) function (total) int(0..2) --> int(0..2) --> int(0..2)
find VAR_0 : set of set of set of int(0..3)
* * * * * * Post Icing * * * * * * * 
find VAR_0 : set of set of set of int(0..3)

+++++++++++++++++++++++++++++++++++++ 
misc.essence
+++++++++++++ Original ++++++++++++++++ 
language Emaxi 2.0

letting vertices be domain int(1..4)
letting k be 5
find R : relation (symmetric,irreflexive,minSize 6) of (vertices * vertices)
such that
$forAll x,y,z : vertices, x!=y, y!=z, z!=x . (!R(x,y) \/ !R(y,z) \/ !R(z,x))
$forAll x,y,z : vertices, x!=y . (!R(x,y) \/ !R(y,z) \/ !R(z,x))
$forAll x,y,z : vertices . (((x!=y) /\ (y!=z) /\ (z!=x)) -> (!R(x,y) \/ !R(y,z) \/ !R(z,x)))
$forAll x,y,z : vertices . (allDiff([x,y,z]) -> (!R(x,y) \/ !R(y,z) \/ !R(z,x)))

$ there is no K_4 induced subgraph
$forAll x,y,z,w : vertices . (allDiff([x,y,z,w]) ->
$   exists {u,v} subsetEq {x,y,z,w} . !R(u,v))

$ there is no K_k induced subgraph
$forAll S subsetEq toSet(`vertices`), |S| = k .
$   (exists {u,v} subsetEq S . !R(u,v))
true


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..4)
letting k be 5
find R : relation (symmetric , irreflexive , minSize 6) of (vertices*vertices)
such that
 true

subsetdiff2.essence
Missing Expression at: 7
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
func_TO_rel.essence
+++++++++++++ Original ++++++++++++++++ 
given n : int(0..100)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting vertices be domain int(0..n-1)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours

given solution : function (total) vertices --> coloursSet

find c : relation (size n*coloursPerNode) of ( vertices * colours )
such that
forAll item in defined(solution) .
    forAll colour in solution(item) .
        c(item, colour)
* * * * * * Post Icing * * * * * * * 
given n : int(0..100)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting vertices be domain int(0..n - 1)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
given solution : function (total) vertices --> coloursSet
find c : relation (size n * coloursPerNode) of (vertices*colours)
such that
   forAll item in defined .
   forAll colour in solution .
     c(item,colour)

+++++++++++++++++++++++++++++++++++++ 
r-sum-1.essence
+++++++++++++ Original ++++++++++++++++ 
find c : int(0..1)
such that
 c = 0 + 1

* * * * * * Post Icing * * * * * * * 
find c : int(0..1)
such that
 c = 0 + 1

+++++++++++++++++++++++++++++++++++++ 
egraph3col2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (colours)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting colours be domain int(1..3)
letting G be relation(((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8)))
find C : relation of (colours)
such that
 forAll (u,v) in G .
     C(u) != C(v)

+++++++++++++++++++++++++++++++++++++ 
testExpression.essence
+++++++++++++ Original ++++++++++++++++ 

    find i : int(0..100)
    such that
        i = 1 * 2 + 3 * 4
    find a : bool
    find b : bool
    find c : bool
    such that
        a = !(b /\ c)
* * * * * * Post Icing * * * * * * * 
find i : int(0..100)
such that
 i = 1 * 2 + 3 * 4
find a : bool
find b : bool
find c : bool
such that
 a = ! ( b /\ c )

+++++++++++++++++++++++++++++++++++++ 
testExpression2.essence
+++++++++++++ Original ++++++++++++++++ 
find i : int(0..100)
such that
i = 1 * 2 + 3 * 4
find a : bool
find b : bool
find c : bool
such that
a = !(b /\ c)
* * * * * * Post Icing * * * * * * * 
find i : int(0..100)
such that
 i = 1 * 2 + 3 * 4
find a : bool
find b : bool
find c : bool
such that
 a = ! ( b /\ c )

+++++++++++++++++++++++++++++++++++++ 
etest4.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such thatÂ Â exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation(((1,2),(1,3))((1,2),(1,3)))
find i : D
such that
 exists j : D .
     (i,j) in R
   ,
   forAll k : D .
   forAll j : D .
     (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
etmp.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation(((1,2),(1,3))((1,2),(1,3)))
find i : D
such that
 exists j : D .
     (i,j) in R
   ,
   forAll k : D .
   forAll j : D .
     (k,j) in R -> (i,j) in R

+++++++++++++++++++++++++++++++++++++ 
gcmulti-functor-funcToRel.essence
+++++++++++++ Original ++++++++++++++++ 
$ graph multicolouring for directed graphs
$ uses exactly coloursPerNode colours for each vertex
given n : int(0..100)
letting vertices be domain int(0..n-1)
given edges : relation (irreflexive) of ( vertices * vertices )
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
forAll (u,v) in edges .
      c(v) intersect c(u) = {}


given n : int(0..100)
letting vertices be domain int(0..n-1)
letting coloursSet be domain set (size coloursPerNode) of colours

given solution : function (total) vertices --> coloursSet

find c : relation (size n*coloursPerNode) of ( vertices * colours )



* * * * * * Post Icing * * * * * * * 
given n : int(0..100)
letting vertices be domain int(0..n - 1)
given edges : relation (irreflexive ) of (vertices*vertices)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
 forAll (u,v) in edges .
     c(v) intersect c(u) = {}
given n : int(0..100)
letting vertices be domain int(0..n - 1)
letting coloursSet be domain set (size coloursPerNode) of colours
given solution : function (total) vertices --> coloursSet
find c : relation (size n * coloursPerNode) of (vertices*colours)

+++++++++++++++++++++++++++++++++++++ 
tiny.essence
+++++++++++++ Original ++++++++++++++++ 
find x : relation of (relation of (int(0..3) * int(0..3)) * int(0..2))

* * * * * * Post Icing * * * * * * * 
find x : relation of (relation of (int(0..3)*int(0..3))*int(0..2))

+++++++++++++++++++++++++++++++++++++ 
nestedfunctiontotalset.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
$find f : function (total) AUXFUNC --> int(0..1)
find fSet : set (maxSize 64) of AUXFUNC


* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find fSet : set (maxSize 64) of AUXFUNC

+++++++++++++++++++++++++++++++++++++ 
nestedfunctiontotalsetchannel.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
$find f : function (total) AUXFUNC --> int(0..1)
find fSet : set (maxSize 64) of AUXFUNC
find f : function (total) AUXFUNC --> int(0..1)
such that
   forAll g in fSet . (f(g) = 1)
,  forAll g in defined(f) . ((f(g) = 0) -> !(g in fSet))


* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find fSet : set (maxSize 64) of AUXFUNC
find f : function (total) AUXFUNC --> int(0..1)
such that
 forAll g in fSet .
     f(g) = 1
   ,
 forAll g in defined .
     f(g) = 0 -> ! ( g in fSet )

+++++++++++++++++++++++++++++++++++++ 
commutative-01.essence
+++++++++++++ Original ++++++++++++++++ 
find a : int(1..6)
find b : int(1..6)
find c : int(1..6)
find d : int(1..6)
such that
  a*b + c*d = 12

* * * * * * Post Icing * * * * * * * 
find a : int(1..6)
find b : int(1..6)
find c : int(1..6)
find d : int(1..6)
such that
 a * b + c * d = 12

gc-simple.essence
'int' object has no attribute 'children'
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
nestedfunctionpartial.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find f : function AUXFUNC --> int(0..1)

* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find f : functionAUXFUNC --> int(0..1)

+++++++++++++++++++++++++++++++++++++ 
deMorgTestOutput.essence
+++++++++++++ Original ++++++++++++++++ 
find a : bool
find b : bool
find c : bool
such that 
  a = ( ! b \/ ! c )

* * * * * * Post Icing * * * * * * * 
find a : bool
find b : bool
find c : bool
such that
 a = ( ! b \/ ! c )

r-sum-2.essence
'int' object has no attribute 'children'
----------------------------- 
subsetdiff1.essence
Missing Expression at: 7
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
etest5.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting T be domain tuple (D,D)
letting R be relation((1,2),(1,3))
find u : T
such that
  exists t in R . (t[1] = 1 /\ u[1] = t[1] /\ u[2] = t[2])

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting T be domain tuple(D,D)
letting R be relation(((1,2),(1,3))((1,2),(1,3)))
find u : T
such that
 exists t in R .
     t[1]  = 1 /\ u[1]  = t[1]  /\ u[2]  = t[2] 

nestedfunctiontotalmatrix.essence
Domain Parsing Error. Token: matrix. Token Num: 24
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
egraph3col.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..10)
letting G be relation((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))
find C : relation of (vertices)
such that
  forAll (u,v) in G .
     C(u) != C(v)

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..10)
letting G be relation(((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8))((1,2),(1,3),(2,3),(4,5),(5,6),(6,7),(7,8),(7,9),(8,9),(9,10),(3,4),(6,1),(2,6),(6,3),(10,8),(1,8)))
find C : relation of (vertices)
such that
 forAll (u,v) in G .
     C(u) != C(v)

graph-shortcheaptour-2017070301.essence
Parsing Error! Token num 2. Expected ':', but got ','.
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
nestedfunctionpartialminsize-smaller.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..1)
find f : function AUXFUNC --> int(0..1)
such that |toSet(f)| >= 3
$ minSize 3

* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..1)
find f : functionAUXFUNC --> int(0..1)
such that
 |

+++++++++++++++++++++++++++++++++++++ 
emini-example2.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
letting T be domain tuple (vertices,colours)
find C : map
find t : T
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))
such that
  t in C
such that
  t[1] = t[2]


* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation(((1,2),(1,3),(2,3))((1,2),(1,3),(2,3))((1,2),(1,3),(2,3)))
letting map be domain relation of (vertices*colours)
letting T be domain tuple(vertices,colours)
find C : map
find t : T
such that
   forAll (u,c) in C .
   forAll (v,d) in C .
     u = v -> c = d
such that
   forAll u : vertices .
   exists c : colours .
     C(u,c)
such that
   forAll (u,v) in G .
   forAll c,d : colours .
     C(u,c) /\ C(v,d) -> c != d
such that
 t in C
such that
 t[1]  = t[2] 

+++++++++++++++++++++++++++++++++++++ 
gcmulti-20-7-2.essence
+++++++++++++ Original ++++++++++++++++ 
letting n be 20
letting vertices be domain int(0..n-1)
letting numberColours be 7
letting coloursPerNode be 2
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours

letting c be
        function(0 --> {1, 2}, 1 --> {3, 4}, 2 --> {1, 2}, 3 --> {3, 4}, 4 --> {1, 2}, 5 --> {3, 4}, 6 --> {5, 6},
                 7 --> {1, 2}, 8 --> {5, 6}, 9 --> {1, 2}, 10 --> {3, 4}, 11 --> {1, 2}, 12 --> {3, 4}, 13 --> {5, 6},
                 14 --> {3, 4}, 15 --> {1, 2}, 16 --> {5, 6}, 17 --> {3, 7}, 18 --> {4, 5}, 19 --> {6, 7})

find cR : relation (size n*coloursPerNode) of ( vertices * colours )
such that
forAll item in defined(c) .
    forAll colour in c(item) .
        cR(item, colour)


* * * * * * Post Icing * * * * * * * 
letting n be 20
letting vertices be domain int(0..n - 1)
letting numberColours be 7
letting coloursPerNode be 2
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
letting c be function(0 --> {1,2},1 --> {3,4},2 --> {1,2},3 --> {3,4},4 --> {1,2},5 --> {3,4},6 --> {5,6},7 --> {1,2},8 --> {5,6},9 --> {1,2},10 --> {3,4},11 --> {1,2},12 --> {3,4},13 --> {5,6},14 --> {3,4},15 --> {1,2},16 --> {5,6},17 --> {3,7},18 --> {4,5},19 --> {6,7})
find cR : relation (size n * coloursPerNode) of (vertices*colours)
such that
   forAll item in defined .
   forAll colour in c .
     cR(item,colour)

+++++++++++++++++++++++++++++++++++++ 
deMorgTest.essence
+++++++++++++ Original ++++++++++++++++ 
letting asdasd be 84
find a : bool
find b : bool
find c : bool
such that
    a = !(b /\ c)
* * * * * * Post Icing * * * * * * * 
letting asdasd be 84
find a : bool
find b : bool
find c : bool
such that
 a = ! ( b /\ c )

+++++++++++++++++++++++++++++++++++++ 
egraph3col4.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
find C : relation of (vertices * colours)
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation(((1,2),(1,3),(2,3))((1,2),(1,3),(2,3))((1,2),(1,3),(2,3)))
find C : relation of (vertices*colours)
such that
   forAll (u,c) in C .
   forAll (v,d) in C .
     u = v -> c = d
such that
   forAll u : vertices .
   exists c : colours .
     C(u,c)
such that
   forAll (u,v) in G .
   forAll c,d : colours .
     C(u,c) /\ C(v,d) -> c != d

subsetdiff4.essence
Missing Expression at: 7
----------------------------- 
streamliner0.essence
pop from empty list
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
etest.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find i : D
such that
  exists j : D . (i,j) in R
, forAll k : D . forAll j : D . ((k,j) in R -> (i,j) in R)

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation(((1,2),(1,3))((1,2),(1,3)))
find i : D
such that
 exists j : D .
     (i,j) in R
   ,
   forAll k : D .
   forAll j : D .
     (k,j) in R -> (i,j) in R

f2seq.essence
Missing Expression at: 7
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
test-spec.essence
+++++++++++++ Original ++++++++++++++++ 
find x :int(0..100)
such that
 x <= 5*2

* * * * * * Post Icing * * * * * * * 
find x : int(0..100)
such that
 x <= 5 * 2

+++++++++++++++++++++++++++++++++++++ 
functiontest.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)

letting f00 be function( 0 --> 0, 1 --> 0, 2 --> 0 )
letting f01 be function( 0 --> 0, 1 --> 0, 2 --> 1 )
letting f02 be function( 0 --> 0, 1 --> 0, 2 --> 2 )
letting f03 be function( 0 --> 0, 1 --> 0, 2 --> 3 )
letting f04 be function( 0 --> 0, 1 --> 1, 2 --> 0 )
letting f05 be function( 0 --> 0, 1 --> 1, 2 --> 1 )
letting f06 be function( 0 --> 0, 1 --> 1, 2 --> 2 )
letting f07 be function( 0 --> 0, 1 --> 1, 2 --> 3 )
letting f08 be function( 0 --> 0, 1 --> 2, 2 --> 0 )
letting f09 be function( 0 --> 0, 1 --> 2, 2 --> 1 )
letting f10 be function( 0 --> 0, 1 --> 2, 2 --> 2 )
letting f11 be function( 0 --> 0, 1 --> 2, 2 --> 3 )
letting f12 be function( 0 --> 0, 1 --> 3, 2 --> 0 )
letting f13 be function( 0 --> 0, 1 --> 3, 2 --> 1 )
letting f14 be function( 0 --> 0, 1 --> 3, 2 --> 2 )
letting f15 be function( 0 --> 0, 1 --> 3, 2 --> 3 )
letting f16 be function( 0 --> 1, 1 --> 0, 2 --> 0 )
letting f17 be function( 0 --> 1, 1 --> 0, 2 --> 1 )
letting f18 be function( 0 --> 1, 1 --> 0, 2 --> 2 )
letting f19 be function( 0 --> 1, 1 --> 0, 2 --> 3 )
letting f20 be function( 0 --> 1, 1 --> 1, 2 --> 0 )
letting f21 be function( 0 --> 1, 1 --> 1, 2 --> 1 )
letting f22 be function( 0 --> 1, 1 --> 1, 2 --> 2 )
letting f23 be function( 0 --> 1, 1 --> 1, 2 --> 3 )
letting f24 be function( 0 --> 1, 1 --> 2, 2 --> 0 )
letting f25 be function( 0 --> 1, 1 --> 2, 2 --> 1 )
letting f26 be function( 0 --> 1, 1 --> 2, 2 --> 2 )
letting f27 be function( 0 --> 1, 1 --> 2, 2 --> 3 )
letting f28 be function( 0 --> 1, 1 --> 3, 2 --> 0 )
letting f29 be function( 0 --> 1, 1 --> 3, 2 --> 1 )
letting f30 be function( 0 --> 1, 1 --> 3, 2 --> 2 )
letting f31 be function( 0 --> 1, 1 --> 3, 2 --> 3 )
letting f32 be function( 0 --> 2, 1 --> 0, 2 --> 0 )
letting f33 be function( 0 --> 2, 1 --> 0, 2 --> 1 )
letting f34 be function( 0 --> 2, 1 --> 0, 2 --> 2 )
letting f35 be function( 0 --> 2, 1 --> 0, 2 --> 3 )
letting f36 be function( 0 --> 2, 1 --> 1, 2 --> 0 )
letting f37 be function( 0 --> 2, 1 --> 1, 2 --> 1 )
letting f38 be function( 0 --> 2, 1 --> 1, 2 --> 2 )
letting f39 be function( 0 --> 2, 1 --> 1, 2 --> 3 )
letting f40 be function( 0 --> 2, 1 --> 2, 2 --> 0 )
letting f41 be function( 0 --> 2, 1 --> 2, 2 --> 1 )
letting f42 be function( 0 --> 2, 1 --> 2, 2 --> 2 )
letting f43 be function( 0 --> 2, 1 --> 2, 2 --> 3 )
letting f44 be function( 0 --> 2, 1 --> 3, 2 --> 0 )
letting f45 be function( 0 --> 2, 1 --> 3, 2 --> 1 )
letting f46 be function( 0 --> 2, 1 --> 3, 2 --> 2 )
letting f47 be function( 0 --> 2, 1 --> 3, 2 --> 3 )
letting f48 be function( 0 --> 3, 1 --> 0, 2 --> 0 )
letting f49 be function( 0 --> 3, 1 --> 0, 2 --> 1 )
letting f50 be function( 0 --> 3, 1 --> 0, 2 --> 2 )
letting f51 be function( 0 --> 3, 1 --> 0, 2 --> 3 )
letting f52 be function( 0 --> 3, 1 --> 1, 2 --> 0 )
letting f53 be function( 0 --> 3, 1 --> 1, 2 --> 1 )
letting f54 be function( 0 --> 3, 1 --> 1, 2 --> 2 )
letting f55 be function( 0 --> 3, 1 --> 1, 2 --> 3 )
letting f56 be function( 0 --> 3, 1 --> 2, 2 --> 0 )
letting f57 be function( 0 --> 3, 1 --> 2, 2 --> 1 )
letting f58 be function( 0 --> 3, 1 --> 2, 2 --> 2 )
letting f59 be function( 0 --> 3, 1 --> 2, 2 --> 3 )
letting f60 be function( 0 --> 3, 1 --> 3, 2 --> 0 )
letting f61 be function( 0 --> 3, 1 --> 3, 2 --> 1 )
letting f62 be function( 0 --> 3, 1 --> 3, 2 --> 2 )
letting f63 be function( 0 --> 3, 1 --> 3, 2 --> 3 )

$ we want to map i : int(0..63) to f<i>
$letting enumFunctions be new type enum {
$f00,f01,f02,f03,f04,f05,f06,f07,f08,f09,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f22,f23,f24,f25,f26,f27,f28,f29,f30,f31,f32,f33,f34,f35,f36,f37,f38,f39,f40,f41,f42,f43,f44,f45,f46,f47,f48,f49,f50,f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61,f62,f63
$}

letting setFunctions be {
f00,f01,f02,f03,f04,f05,f06,f07,f08,f09,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f22,f23,f24,f25,f26,f27,f28,f29,f30,f31,f32,f33,f34,f35,f36,f37,f38,f39,f40,f41,f42,f43,f44,f45,f46,f47,f48,f49,f50,f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61,f62,f63
}

$ matrix:
$find fMatrix : matrix indexed by [int(0..63)] of int(0..1)

$find fMatrix : matrix indexed by [enumFunctions] of int(0..1)

$ set:
$find fSet : set of AUXFUNC

$ original:
$ find f : function AUXFUNC --> int(0..1)

find x : AUXFUNC
such that x in setFunctions

find y : int(0..1)
$ the answer is: x --> y


* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
letting f00 be function(0 --> 0,1 --> 0,2 --> 0)
letting f01 be function(0 --> 0,1 --> 0,2 --> 1)
letting f02 be function(0 --> 0,1 --> 0,2 --> 2)
letting f03 be function(0 --> 0,1 --> 0,2 --> 3)
letting f04 be function(0 --> 0,1 --> 1,2 --> 0)
letting f05 be function(0 --> 0,1 --> 1,2 --> 1)
letting f06 be function(0 --> 0,1 --> 1,2 --> 2)
letting f07 be function(0 --> 0,1 --> 1,2 --> 3)
letting f08 be function(0 --> 0,1 --> 2,2 --> 0)
letting f09 be function(0 --> 0,1 --> 2,2 --> 1)
letting f10 be function(0 --> 0,1 --> 2,2 --> 2)
letting f11 be function(0 --> 0,1 --> 2,2 --> 3)
letting f12 be function(0 --> 0,1 --> 3,2 --> 0)
letting f13 be function(0 --> 0,1 --> 3,2 --> 1)
letting f14 be function(0 --> 0,1 --> 3,2 --> 2)
letting f15 be function(0 --> 0,1 --> 3,2 --> 3)
letting f16 be function(0 --> 1,1 --> 0,2 --> 0)
letting f17 be function(0 --> 1,1 --> 0,2 --> 1)
letting f18 be function(0 --> 1,1 --> 0,2 --> 2)
letting f19 be function(0 --> 1,1 --> 0,2 --> 3)
letting f20 be function(0 --> 1,1 --> 1,2 --> 0)
letting f21 be function(0 --> 1,1 --> 1,2 --> 1)
letting f22 be function(0 --> 1,1 --> 1,2 --> 2)
letting f23 be function(0 --> 1,1 --> 1,2 --> 3)
letting f24 be function(0 --> 1,1 --> 2,2 --> 0)
letting f25 be function(0 --> 1,1 --> 2,2 --> 1)
letting f26 be function(0 --> 1,1 --> 2,2 --> 2)
letting f27 be function(0 --> 1,1 --> 2,2 --> 3)
letting f28 be function(0 --> 1,1 --> 3,2 --> 0)
letting f29 be function(0 --> 1,1 --> 3,2 --> 1)
letting f30 be function(0 --> 1,1 --> 3,2 --> 2)
letting f31 be function(0 --> 1,1 --> 3,2 --> 3)
letting f32 be function(0 --> 2,1 --> 0,2 --> 0)
letting f33 be function(0 --> 2,1 --> 0,2 --> 1)
letting f34 be function(0 --> 2,1 --> 0,2 --> 2)
letting f35 be function(0 --> 2,1 --> 0,2 --> 3)
letting f36 be function(0 --> 2,1 --> 1,2 --> 0)
letting f37 be function(0 --> 2,1 --> 1,2 --> 1)
letting f38 be function(0 --> 2,1 --> 1,2 --> 2)
letting f39 be function(0 --> 2,1 --> 1,2 --> 3)
letting f40 be function(0 --> 2,1 --> 2,2 --> 0)
letting f41 be function(0 --> 2,1 --> 2,2 --> 1)
letting f42 be function(0 --> 2,1 --> 2,2 --> 2)
letting f43 be function(0 --> 2,1 --> 2,2 --> 3)
letting f44 be function(0 --> 2,1 --> 3,2 --> 0)
letting f45 be function(0 --> 2,1 --> 3,2 --> 1)
letting f46 be function(0 --> 2,1 --> 3,2 --> 2)
letting f47 be function(0 --> 2,1 --> 3,2 --> 3)
letting f48 be function(0 --> 3,1 --> 0,2 --> 0)
letting f49 be function(0 --> 3,1 --> 0,2 --> 1)
letting f50 be function(0 --> 3,1 --> 0,2 --> 2)
letting f51 be function(0 --> 3,1 --> 0,2 --> 3)
letting f52 be function(0 --> 3,1 --> 1,2 --> 0)
letting f53 be function(0 --> 3,1 --> 1,2 --> 1)
letting f54 be function(0 --> 3,1 --> 1,2 --> 2)
letting f55 be function(0 --> 3,1 --> 1,2 --> 3)
letting f56 be function(0 --> 3,1 --> 2,2 --> 0)
letting f57 be function(0 --> 3,1 --> 2,2 --> 1)
letting f58 be function(0 --> 3,1 --> 2,2 --> 2)
letting f59 be function(0 --> 3,1 --> 2,2 --> 3)
letting f60 be function(0 --> 3,1 --> 3,2 --> 0)
letting f61 be function(0 --> 3,1 --> 3,2 --> 1)
letting f62 be function(0 --> 3,1 --> 3,2 --> 2)
letting f63 be function(0 --> 3,1 --> 3,2 --> 3)
letting setFunctions be {f00,f01,f02,f03,f04,f05,f06,f07,f08,f09,f10,f11,f12,f13,f14,f15,f16,f17,f18,f19,f20,f21,f22,f23,f24,f25,f26,f27,f28,f29,f30,f31,f32,f33,f34,f35,f36,f37,f38,f39,f40,f41,f42,f43,f44,f45,f46,f47,f48,f49,f50,f51,f52,f53,f54,f55,f56,f57,f58,f59,f60,f61,f62,f63}
find x : AUXFUNC
such that
 x in setFunctions
find y : int(0..1)

+++++++++++++++++++++++++++++++++++++ 
treetest.essence
+++++++++++++ Original ++++++++++++++++ 
letting n be 12
letting V be domain int(0..n)
find edges : relation (size n) of (V * V)
such that
  forAll edge,edge2 in edges .
    edge[2] > edge[1] /\
      ((edge != edge2) -> (edge[2] != edge2[2]))

* * * * * * Post Icing * * * * * * * 
letting n be 12
letting V be domain int(0..n)
find edges : relation (size n) of (V*V)
such that
 forAll edge,edge2 in edges .
     edge[2]  > edge[1]  /\ ( edge != edge2 -> edge[2]  != edge2[2]  )

+++++++++++++++++++++++++++++++++++++ 
transformed_gc_multi.essence
+++++++++++++ Original ++++++++++++++++ 
given n : int(1..100)
letting vertices be domain int(0..n - 1)
given edges : relation (irreflexive ) of (vertices*vertices)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
 true
   ,
 forAll (u,v) in edges .
     c(v) intersect c(u) = {}
* * * * * * Post Icing * * * * * * * 
given n : int(1..100)
letting vertices be domain int(0..n - 1)
given edges : relation (irreflexive ) of (vertices*vertices)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
 true
   ,
 forAll (u,v) in edges .
     c(v) intersect c(u) = {}

+++++++++++++++++++++++++++++++++++++ 
treeGen.essence
+++++++++++++ Original ++++++++++++++++ 
letting n be 12
letting vertices be domain int(0..n)
find edges : relation (size n) of (vertices * vertices)
such that
    forAll edge,edge2 in edges .
        edge[2] > edge[1] /\
        ((edge != edge2) -> (edge[2] != edge2[2]))
* * * * * * Post Icing * * * * * * * 
letting n be 12
letting vertices be domain int(0..n)
find edges : relation (size n) of (vertices*vertices)
such that
 forAll edge,edge2 in edges .
     edge[2]  > edge[1]  /\ ( edge != edge2 -> edge[2]  != edge2[2]  )

+++++++++++++++++++++++++++++++++++++ 
sum.essence
+++++++++++++ Original ++++++++++++++++ 
find f : int(0..10)
such that f = sum i : int(1..3) . i

* * * * * * Post Icing * * * * * * * 
find f : int(0..10)
such that
   f = sum i : int(1..3) .
     i

+++++++++++++++++++++++++++++++++++++ 
tiny1.essence
+++++++++++++ Original ++++++++++++++++ 
find x : function function int(0..3) --> int(0..3) --> int(0..2)

* * * * * * Post Icing * * * * * * * 
find x : functionfunctionint(0..3) --> int(0..3) --> int(0..2)

subsetsum2.essence
Missing Expression at: 7
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
nestedfunctiontotal.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find f : function (total) AUXFUNC --> int(0..1)

* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find f : function (total) AUXFUNC --> int(0..1)

gcmulti.essence
Missing Expression at: 36
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
sumtest.essence
+++++++++++++ Original ++++++++++++++++ 
find s : int(1..200)
such that s = sum i : int(1..10) . toInt(i%2 = 0) + 5

* * * * * * Post Icing * * * * * * * 
find s : int(1..200)
such that
   s = sum i : int(1..10) .
     toInt ( i % 2 = 0 ) + 5

+++++++++++++++++++++++++++++++++++++ 
nestedfunctiontotalsetminsize.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
$find f : function (total) AUXFUNC --> int(0..1)
find fSet : set (maxSize 64, minSize 3) of AUXFUNC


* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find fSet : set (maxSize 64, minSize 3) of AUXFUNC

+++++++++++++++++++++++++++++++++++++ 
gcmulti-funcXOR.essence
+++++++++++++ Original ++++++++++++++++ 
$ k-fold graph colouring with k=coloursPerNode, out of numberColours
given n : int(0..100)
letting vertices be domain int(0..n-1)
given edges : relation (irreflexive) of ( vertices * vertices )
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
forAll (u,v) in edges .
      c(v) intersect c(u) = {}


* * * * * * Post Icing * * * * * * * 
given n : int(0..100)
letting vertices be domain int(0..n - 1)
given edges : relation (irreflexive ) of (vertices*vertices)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
 forAll (u,v) in edges .
     c(v) intersect c(u) = {}

+++++++++++++++++++++++++++++++++++++ 
etest3.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..2)
letting R be domain relation of (D * D)
find i : D
such that
exists j : D . (i,j) in R

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..2)
letting R be domain relation of (D*D)
find i : D
such that
 exists j : D .
     (i,j) in R

gcmulti-func-instanceRepair.essence
list index out of range
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
emini-example1.essence
+++++++++++++ Original ++++++++++++++++ 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation((1,2),(1,3),(2,3))
letting map be domain relation of (vertices * colours)
find C : map
such that
  forAll (u,c) in C .
     forAll (v,d) in C .
        ((u = v) -> (c = d))
such that
  forAll u : vertices .
     exists c : colours . C(u,c)
such that
  forAll (u,v) in G .
     forAll c,d : colours . (C(u,c) /\ C(v,d) -> (c != d))

* * * * * * Post Icing * * * * * * * 
letting vertices be domain int(1..3)
letting colours be domain int(1..3)
letting G be relation(((1,2),(1,3),(2,3))((1,2),(1,3),(2,3))((1,2),(1,3),(2,3)))
letting map be domain relation of (vertices*colours)
find C : map
such that
   forAll (u,c) in C .
   forAll (v,d) in C .
     u = v -> c = d
such that
   forAll u : vertices .
   exists c : colours .
     C(u,c)
such that
   forAll (u,v) in G .
   forAll c,d : colours .
     C(u,c) /\ C(v,d) -> c != d

gc.essence
Missing Expression at: 31
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
gcmulti-func.essence
+++++++++++++ Original ++++++++++++++++ 
$ k-fold graph colouring with k=coloursPerNode, out of numberColours
given n : int(0..100)
letting vertices be domain int(0..n-1)
given edges : relation (irreflexive) of ( vertices * vertices )
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
forAll (u,v) in edges .
      c(v) intersect c(u) = {}


* * * * * * Post Icing * * * * * * * 
given n : int(0..100)
letting vertices be domain int(0..n - 1)
given edges : relation (irreflexive ) of (vertices*vertices)
given numberColours : int(1..n)
given coloursPerNode : int(1..n)
letting colours be domain int(1..numberColours)
letting coloursSet be domain set (size coloursPerNode) of colours
find c : function (total) vertices --> coloursSet
such that
 forAll (u,v) in edges .
     c(v) intersect c(u) = {}

+++++++++++++++++++++++++++++++++++++ 
etest2.essence
+++++++++++++ Original ++++++++++++++++ 
letting D be domain int(1..3)
letting Rtype be domain relation of (D * D)
letting R be relation((1,2),(1,3))
find S : Rtype
such that
  forAll (x,y) in S .
     (y,x) in R
, forAll (x,y) in R .
     (y,x) in S

* * * * * * Post Icing * * * * * * * 
letting D be domain int(1..3)
letting Rtype be domain relation of (D*D)
letting R be relation(((1,2),(1,3))((1,2),(1,3)))
find S : Rtype
such that
 forAll (x,y) in S .
     (y,x) in R
   ,
 forAll (x,y) in R .
     (y,x) in S

+++++++++++++++++++++++++++++++++++++ 
nestedfunctionpartialminsize.essence
+++++++++++++ Original ++++++++++++++++ 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find f : function AUXFUNC --> int(0..1)
such that |toSet(f)| >= 3
$ minSize 3

* * * * * * Post Icing * * * * * * * 
letting AUXFUNC be domain function (total) int(0..2) --> int(0..3)
find f : functionAUXFUNC --> int(0..1)
such that
 |

subsetsum1.essence
Missing Expression at: 7
----------------------------- 
+++++++++++++++++++++++++++++++++++++ 
tiny2.essence
+++++++++++++ Original ++++++++++++++++ 
find x : set (minSize 1) of function (total) int(0..2) --> int(0..2)

* * * * * * Post Icing * * * * * * * 
find x : set (minSize 1) of function (total) int(0..2) --> int(0..2)

+++++++++++++++++++++++++++++++++++++ 
gcmulti-func-instanceGenerator.essence
+++++++++++++ Original ++++++++++++++++ 
language Essence 1.3

given n_min: int(0..100)
given n_max: int(0..100)
find n: int(0..100)
such that
    n >= n_min,
    n <= n_max
given edges_cardMin: int(0..100)
given edges_cardMax: int(0..100)
given edges_relation1_min: int(0..99)
given edges_relation1_max: int(0..99)
given edges_relation2_min: int(0..99)
given edges_relation2_max: int(0..99)
find edges: relation (maxSize 100, irreflexive) of (int(0..99) * int(0..99))
such that
    |edges| >= edges_cardMin /\ |edges| <= edges_cardMax,
    and([q1[1] >= edges_relation1_min | q1 <- edges]),
    and([q1[1] <= edges_relation1_max | q1 <- edges]),
    and([q1[1] <= n - 1 | q1 <- edges]),
    and([q1[2] >= edges_relation2_min | q1 <- edges]),
    and([q1[2] <= edges_relation2_max | q1 <- edges]),
    and([q1[2] <= n - 1 | q1 <- edges])
given numberColours_min: int(1..100)
given numberColours_max: int(1..100)
find numberColours: int(1..100)
such that
    numberColours >= numberColours_min,
    numberColours <= numberColours_max,
    numberColours <= n
given coloursPerNode_min: int(1..100)
given coloursPerNode_max: int(1..100)
find coloursPerNode: int(1..100)
such that
    coloursPerNode >= coloursPerNode_min,
    coloursPerNode <= coloursPerNode_max,
    coloursPerNode <= n

* * * * * * Post Icing * * * * * * * 
given n_min : int(0..100)
given n_max : int(0..100)
find n : int(0..100)
such that
 n >= n_min
   ,
 n <= n_max
given edges_cardMin : int(0..100)
given edges_cardMax : int(0..100)
given edges_relation1_min : int(0..99)
given edges_relation1_max : int(0..99)
given edges_relation2_min : int(0..99)
given edges_relation2_max : int(0..99)
find edges : relation (maxSize 100, irreflexive ) of (int(0..99)*int(0..99))
such that
 |
   ,
 [
   ,
 [
   ,
 [
   ,
 [
   ,
 [
   ,
 [
given numberColours_min : int(1..100)
given numberColours_max : int(1..100)
find numberColours : int(1..100)
such that
 numberColours >= numberColours_min
   ,
 numberColours <= numberColours_max
   ,
 numberColours <= n
given coloursPerNode_min : int(1..100)
given coloursPerNode_max : int(1..100)
find coloursPerNode : int(1..100)
such that
 coloursPerNode >= coloursPerNode_min
   ,
 coloursPerNode <= coloursPerNode_max
   ,
 coloursPerNode <= n

+++++++++++++++++++++++++++++++++++++ 
stalltest.essence
+++++++++++++ Original ++++++++++++++++ 
$$$ search for the shortest stall $$$
$find VAR_0 : function function int(0..3) --> int(0..3) --> int(0..2)

$letting AUX_0 be domain set (maxSize 4) of tuple(int(0..3),int(0..3))
$find VAR_0 : set of tuple(AUX_0, int(0..2))
$
$find VAR_0 : function (total) function (total) int(0..2) --> int(0..2) --> int(0..2)
find VAR_0 : relation of (relation of (int(0..3) * int(0..3)) * int(0..2))
* * * * * * Post Icing * * * * * * * 
find VAR_0 : relation of (relation of (int(0..3)*int(0..3))*int(0..2))

