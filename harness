#!/usr/bin/env python3
# read spec
#  parse arguments
#  locate relevant files
#  concatenate spec and parameter files
#  get AST via Conjure
# benchmark performance
#  time running conjure solve
# apply rewriting
#  call rewriting system with specified rewrite
#  check rewrite actually made a change
# if rewrite happened, benchmark performance of new spec
#  concatenate spec and parameter files
# report comparison

import sys
import argparse
p = argparse.ArgumentParser()
p.add_argument('-s', '--spec', action='store')
p.add_argument('-p', '--param', action='store')
p.add_argument('-r', '--rewrite', action='store')
args = p.parse_args(args=sys.argv[1:])
# args.spec is the input spec filename
# args.param is the input param filename
# args.rewrite is the kind of rewrite to perform
print(args.spec, args.param, args.rewrite)

import pathlib
from pathlib import Path
if args.spec:
    specfile = Path(args.spec)
else:
    sys.exit('A spec file must be provided, quitting')
if specfile.is_file():
    print('found spec file', specfile)
else:
    sys.exit('A spec file must be provided, quitting')
doParam = False
if args.param:
    paramfile = Path(args.param)
    doParam = paramfile.is_file()
if doParam:
    print('found param file', paramfile)
    filenames = [paramfile, specfile]
else:
    filenames = [specfile]

# generate temp file name
tmpfile = './temp-042.essence'
with open(tmpfile, 'w') as outfile:
    for fname in filenames:
        with open(fname, 'r') as infile:
            outfile.write(infile.read())

# ask conjure to generate AST
# from spec.bla make spec.bla.astjson
astfilename = '{0}.astjson'.format(specfile)
import subprocess
with open(astfilename, 'w') as astfile:
    if subprocess.run(['conjure',
                       'pretty', '--output-format=astjson', tmpfile],
                      shell=False, stdout=astfile).returncode != 0:
        sys.exit('Something went wrong with calling conjure, quitting')

# read conjure JSON output representing an Essence spec

import json
with open(astfilename, 'r') as astfile:
    A = json.load(astfile)

ni = 0
nodeLabel = []

def makeNode(label):
    global ni, nodeLabel
    nodeLabel.append(label)
    rv = ni
    ni += 1
    return rv

ei = 0
edgeLabel = []
edgeFrom = []
edgeTo = []

def makeEdge(u,v,label):
    global ei, edgeLabel, edgeFrom, edgeTo
    edgeLabel.append(label)
    edgeFrom.append(u)
    edgeTo.append(v)
    rv = ei
    ei += 1
    return rv

def processSubtree(label,value):
    u = makeNode(label)
    if isinstance(value, list):
        nodeType = 'firstChild'
        prev = u
        for s in value:
            v = makeNode(s)
            makeEdge(prev, v, nodeType)
            nodeType = 'nextChild'
            prev = v
    elif isinstance(value, dict):
        for s in value:
            v = makeNode(s)
            makeEdge(u, v, 'Child')
    else:
        print('error, cannot determine type of', value)
    return u

r = makeNode('root')
for label in A:
    u = processSubtree(label,A[label])
    makeEdge(r, u, label)

print('nodeLabel=', nodeLabel)
for l,f,t in zip(edgeLabel, edgeFrom, edgeTo):
    print('(', f, ',', t, ':', l, ')')
#print('edgeLabel=', edgeLabel)
#print('edgeFrom=', edgeFrom)
#print('edgeTo=', edgeTo)

# main ::= letting | given | such_that | where | find

# print(A['mLanguage']['language']['Name']) # Essence
# print(A['mLanguage']['version']) # 1.3
statements = A['mStatements']
print(len(statements), "statements")
for s in statements:
    for keyword in s:
        print(keyword, '=', s[keyword])
    if 'Declaration' in s:
        s2 = s['Declaration']
        print('processing declaration')
        if 'FindOrGiven' in s2:
            print('processing FindOrGiven')
            s3 = s2['FindOrGiven']
            if 'Find' == s3[0]:
                nameBlob = s3[1]
                domainBlob = s3[2]
                print('find', '<', nameBlob['Name'], '>', '<', domainBlob, '>')
            else:
                print('not find')
        elif 'Letting' in s2:
            print('processing Letting')
        else:
            print('not FindOrGiven or Letting')
    elif 'SuchThat' in s:
        print('processing such that')
    elif 'Where' in s:
        print('processing where')
    elif 'Find' in s:
        print('processing find')

    print()

    if not 'SuchThat' in s: continue
    c = s['SuchThat']
    if not c: continue
    for constraint in c:
        if not 'Op' in constraint: continue
        d = constraint['Op']
        if not d: continue
        if not 'MkOpEq' in d: continue
        e = d['MkOpEq']
        if len(e) != 2: continue
        lhs = e[0]
        rhs = e[1]
        # print(lhs, '=', rhs)
        if len(lhs) == 1 and 'Op' in rhs:
             rhs = rhs['Op']
             if 'MkOpSum' in rhs:
                 rhs = rhs['MkOpSum']
                 if not 'AbstractLiteral' in rhs: continue
                 rhs = rhs['AbstractLiteral']['AbsLitMatrix']
                 if len(rhs) == 2:
                     lhs = rhs[0]
                     rhs = rhs[1]
                     print(lhs, '+', rhs)

# want to rewrite:
# X '+' Y -> Y '+' X
# if X > Y lexically and they are both non-constant expressions
# X + Y -> value(X) + value(Y)
# if they are both constants

#print(A)
